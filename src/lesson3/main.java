package lesson3;

//        Задание
//
//        Урок 3. Стек и очередь
//        1. Создать класс для реализации дека (двухсторонняя очередь).
//        2. Создать класс для реализации приоритетной очереди (выбрать только один из вариантов)
//        3. описать метод проверки скобочной последовательности (см. код урока, комментарий под главным классом)

public class main {
    public static void main(String[] args) {
        System.out.println("Hello in Lesson 3");

    }
}


/**
 * Двусторонняя очередь  – очередь, у которой нет явно выраженного конца и начала.
 * Она может расти и уменьшаться в обоих направлениях.
 */
class Deque {
    int size; //размер
    int head = -1; // указвтель на голову
    int tail = 0; // указатель на хвост
    int[] data;

    /** проверка что очередь  пустая , если head == -1, то она пуста */
    boolean isEmpty() {
        return head == tail;
    }

    /** проверка что очередь заполнена**/
    boolean isFull() {
        return ((head == 0 && tail == size - 1) || head == tail + 1);
    }

    /** добавить элемент в начало очереди **/
    void pushFront(int value) {
        if (isFull()) {                     // проверка, что в очереди есть место
            System.out.println("Переполнение");
            return;
        }

        if (head < 1) {           //если индекс на начало < 1, то
            head = size - 1;    //передвигаем его на последний эл-т массива
        } else {                // иначе
            head++;             // увеличиваем указатель на 1
            data[head] = value; // присваеваем значение в голову очереди
        }
    }

    /** вставка в конец очереди */
    void pushBack(int value) {

        if (isFull()) {                     // проверка, что в очереди есть место
            System.out.println("Переполнение");
            return;
        }

        if (head == -1) {               // если указатель на голову =-1, тогда
            head = 0;                   // тогда ставим указатели хвоста и головы равными 0, т.е в начало
            tail = 0;
        } else if (tail == size - 1) {   // или, если указатель на хвост = size - 1
            tail = 0;                    // тогда указатель на хвост устанавливаем = 0
        } else {
            tail = tail + 1;            // если все условия выше не выполнены, тогда tail = tail + 1
        }

        data[tail] = value;             // присваеваем значение в хвост очереди
    }

    /** получить элемент из начала очереди **/
    int popFront() {
        if (++head == size)             // если указатель головы указывает на конец массива,
            head = 0;                   // то переместить указатель головы в начало массива на 0
        return data[head];              // вернуть значение из головы
    }

    /** получить элемент из хвоста очереди **/
    int popBack() {
        int res = data[tail];
        if (--tail < 0)                 // если указатель хвоста указывает на начало массива, то после получения значения
            tail = size - 1;            // перемещаем указатель хвоста массива  на начало массива
        return res;
    }
}
